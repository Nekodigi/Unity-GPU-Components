// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Initialize
#pragma kernel Update

#include "Assets/Scripts/Value/Random.cginc"
#include "Assets/Scripts/Particle/Particle.hlsl"
#include "Assets/Scripts/Particle/Function/GetFieldValue.hlsl"
#include "Assets/Scripts/Particle/Function/Boundary.hlsl"
#include "Assets/Scripts/Utils/Time/Time.hlsl"

float3 _VelMin;
float3 _VelMax;
float3 _SizeMin;
float3 _SizeMax;
Texture2D<float4> _ColorDist;
#ifndef FIELD
SamplerState linearClampSampler;
#endif

static const float PI = 3.14159265f;

[numthreads(128, 1, 1)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
    particle p = _ParticleBuffer[id.x];
    p.pos = _PosMin + random3(id.xxx)*(_PosMax-_PosMin);
    p.vel = _VelMin + random3(id.xxx+1)*(_VelMax-_VelMin);
    p.rot = random3(id.xxx+2)*2*PI;
    p.rotVel = random3(id.xxx+3);
    p.size = _SizeMin + random3(id.xxx+4)*(_SizeMax-_SizeMin);
    p.spawnTime = _Time;
    p.lifeTime = 10;
    p.enable = true;
    //p.col = float4(random3(id), 1);
    p.col = _ColorDist.SampleLevel(linearClampSampler, random2(id.xxx+5), 0);
    _ParticleBuffer[id.x] = p;
}

[numthreads(128, 1, 1)]
void Update(uint3 id : SV_DispatchThreadID)
{
    particle p = _ParticleBuffer[id.x];
    p.pos += p.vel * _DeltaTime;
    p.rot += p.rotVel * _DeltaTime;
    float2 vec = GetFieldVec(id.x);
    p.pos += float3(vec.x,0,vec.y);
    _ParticleBuffer[id.x] = p;
    LoopBoundary(id.x);
}